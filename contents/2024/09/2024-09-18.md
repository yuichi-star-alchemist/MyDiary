とりあえずUUIDを代入せずにcreateしてみました  
もちろんエラーにはなるのですが、paramsのタプルの中でNoneになっているのが、
Djangoのエラーコード履歴を見ると表示されていました  
なるほど、こういう風にエラーを起こさせると、辿るルートがわかると・・！  
  
そしてやっと判明しました・・！  
ForeignKeyには、参照先モデルと恐らくpkではない列番号のような参照を代入しておくようで、オブジェクト.__str__(.pkではない)によって返される値がテーブル内で表示されるデータになる模様です  
(表示はそうですが実際はオブジェクトデータを格納するようです)
ただ、AbstractBaseUser内でpkではなくsettings.USERNAME_FIELDの値を取得して返すようになっているため、継承後にpkを返すようにオーバーライドすればうまく行きました  
```
class AppUsers(AbstractUser):
    def __str__(self):
        return str(self.pk)
```
modelの__str__を変更すると既に登録済みのタスクのuser_idもAppUsersのpkが表示されるようになっていました

要約: ForeignKeyのフィールドには参照先のモデル名とその列番号(オブジェクト番号)を含むオブジェクトを代入する
データベース表示や認証などでカラムの値を取得しようとすると.__str__()で取得した値を使用する